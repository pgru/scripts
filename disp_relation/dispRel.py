__author__ = 'TaytaInti'
# makes plots with results of simmulation using .dat files generated by oommf2matrix (MATLAB datas)
# important, show localisation of file /head.tcl/

import os
import numpy as np
import matplotlib.image as mpimg
import matplotlib.pyplot as plt
import matplotlib.colors as colors


# lambda_EM = 532e-09
# k = 4*pi*sin(20*pi/180)/lambda_EM
#k = 8.1e+06    #[1/m]     wektor falowy fali spinowej
# A  = 13e-12		# [J/m] Py     stala wymiany
# Ms = 800e+03	# [A/m] Py      namagnesowanie nasycenia
# Ms_Co := 1.45e+06
# Ms_YIG := 0.194e+06
# A_Co := 3e-11
# A_YIG := 0.4e-11
A  = 0.4e-11	# [J/m]     stala wymiany
Ms = 0.194e+06	# [A/m]       namagnesowanie nasycenia

gamma = 176e+09 # [Hz/T]    wsp gyromagnetyczny 
d = 5e-09		# [m]       grubosc probki
mi0 = 4*np.pi*1e-07 # [V*s/A*m]

# mi0H0 = [0.1:0.1:0.7]    # H0 * mi0
# mi0H0 = np.arange(0.2,10.8,0.2)    # H0 * mi0

mi0HDCLi = np.arange(0.3,2.4,0.5)  
# mi0H0Li = map(lambda H0: H0-Ms*mi0, mi0HDCLi)	# for Forward Volume SWs
# mi0H0Li = mi0HDCLi	# for Backward Volume SWs and Surface SWs
mi0Ha = 0 	#-0.08;           # [T] - szac.


omM = gamma*mi0*Ms
omega0 = lambda k, mi0H0: gamma*mi0H0 #+ gamma*(2*A/Ms)*k*k + gamma*mi0Ha
omega2 = lambda om0, k: om0*(om0+omM) + 0.25*(omM**2)*(1-np.exp(-2*k*d))	# Surface SWs
# omega2 = lambda om0, kz: om0*(om0+omM*(1-np.exp(-2*kz*d))/(kz*d) )	# Backward Volume SWs
# omega2 = lambda om0, kt: om0*(om0+omM*( 1 - (1-np.exp(-kt*d))/(kt*d) ) )	# Forward Volume SWs

# H = 2/mi0
# D = 5e-09
# fi = 45
# omega2 = lambda om0, k: gamma*np.sqrt( (H+D*k**2)*(H+D*k**2+4*np.pi*(np.sin(fi))**2 ) )


[k0, kf] = [0, 5e06]
kLi = np.arange(k0, kf, kf/10000)

ax1 = plt.subplot(311)
colorsLi = ["b", "g", "r", "c", "m", "y", "k"]
# i=0
# mi0H0Li = map(lambda H0: H0-Ms*mi0, mi0HDCLi)	# for Forward Volume SWs
# mi0H0Li = mi0HDCLi	# for Backward Volume SWs and Surface SWs
for mi0DC in mi0HDCLi:
	# mi0H0 = mi0DC-mi0*Ms
	mi0H0 = mi0DC
	f = []
	for k in kLi:
		ft = np.sqrt(omega2(omega0(k, mi0H0), k)) / (2*np.pi)
		f.append(ft)
	# plt.plot(kLi, f, color=colorsLi[i%len(colorsLi)], label=str(mi0H0))
	ax1.plot(kLi, f, label=str(mi0DC))
	# i+=1
ax1.legend(ncol=1, fancybox=True, shadow=True)
ax1.set_title(r'Dispersion relation for diffrent values of $H_{DC} [T]$ ')
ax1.set_xlabel(r'$f [Hz]$')
ax1.set_ylabel(r'$k [1/m]$')

mi0HDC = 0.3
# mi0H0  = mi0HDC - mi0*Ms
mi0H0  = mi0HDC
fLi=[]
for k in kLi:
	ft = np.sqrt(omega2(omega0(k, mi0H0),k))/(2*np.pi)
	fLi.append(ft)

v_grLi=[]
st = 1
for i in range(len(kLi)-st):
	k= kLi[i+1]
	v_grLi.append( 2*np.pi * (fLi[i]-fLi[i-1])/(kLi[i]-kLi[i-1]) )
	#v_grLi.append( 2*np.pi * (fLi[i])/(kLi[i]) )


ax2 = plt.subplot(312)
ax2.plot(kLi[st+2:(len(kLi)+st-1)], v_grLi[1:len(v_grLi)-1], label=str(mi0HDC))
ax2.legend(fancybox=True, shadow=True)
# ax2.set_title(r'Group velocity $v_{gr} [m/s]$')
ax2.set_xlabel(r'$v_{gr} [m/s]$')
ax2.set_ylabel(r'$k [1/m]$')

lambLi = []
for i in range(len(v_grLi)): 
	lambLi.append(v_grLi[i]/fLi[i])

ax3 = plt.subplot(313)
ax3.plot(fLi[st+2:(len(fLi)+st-1)], lambLi[1:len(v_grLi)-1], label=str(mi0HDC))
ax3.legend(fancybox=True, shadow=True)
# ax3.set_title(r'Wavelength $\lambda [m]$')
ax3.set_xlabel(r'$f [1/m]$')
ax3.set_ylabel(r'$\lambda [m]$')

print "mi0*Ms", mi0*Ms
print "mi0H0", mi0H0
plt.show()
plt.close()
# a = ( f(length(f)) - f(2) )/(mi0H0(length(f)) - mi0H0(2))
# b = f(1);
