bbbb__author__ = 'TaytaInti'
# makes plots with results of simmulation using .dat files generated by oommf2matrix (MATLAB datas)
# important, show localisation of file /head.tcl/

import os
import numpy as np
import matplotlib.image as mpimg
import matplotlib.pyplot as plt
import matplotlib.colors as colors

import re as re
import struct


def getData(filename):
    print "getData" 
    with open(filename, 'rb') as f:
        print "omf file opened"
        headers = {} #I know valuemultiplier isn't always present. This is checked later.
        extraCaptures = {'SimTime':-1, 'Iteration':-1, 'Stage':-1, "MIFSource":""}
        #Parse headers
        a = ""
        print "loading file"
        while not "Begin: Data" in a:
            a = f.readline().strip()
            #Determine if it's actually something we need as header data
            for key in ["xbase", "ybase", "zbase", "xstepsize", "ystepsize", "zstepsize", "xnodes", "ynodes", "znodes", "valuemultiplier"]:
                if key in a:
                    headers[key] = float(a.split()[2]) #Known position FTW
            #All right, it may also be time data, which we should capture
            if "Total simulation time" in a:
                #Split on the colon to get the time with units; strip spaces and split on the space to separate time and units
                #Finally, pluck out the time, stripping defensively (which should be unnecessary).
                extraCaptures['SimTime'] = float(a.split(":")[-1].strip().split()[0].strip())
            if "Iteration:" in a:
                #Another tricky split...
                extraCaptures['Iteration'] = float(a.split(":")[2].split(",")[0].strip())
            if "Stage:" in a:
                extraCaptures['Stage'] = float(a.split(":")[2].split(",")[0].strip())
            if "MIF source file" in a:
                extraCaptures['MIFSource'] = a.split(":",2)[2].strip()
        
        print "loaded file, processing..."
        #Initialize array to be populated
        outArray = np.zeros((int(headers["xnodes"]),
                             int(headers["ynodes"]),
                             int(headers["znodes"]),
                             3))

        #Determine decoding mode and use that to populate the array
        print "Data indicator:", a
        decode = a.split()
        if decode[3] == "Text":
            pass
            #return textDecode(f, outArray, headers, extraCaptures)
        elif (decode[3] == "Binary" or decode[3] == "binary")  and decode[4] == "4":
            #Determine endianness
            endianflag = f.read(4)
            if struct.unpack(">f", endianflag)[0] == 1234567.0:
                print "Big-endian 4-byte detected."
                dc = struct.Struct(">f")
            elif struct.unpack("<f", endianflag)[0] == 1234567.0:
                print "Little-endian 4-byte detected."
                dc = struct.Struct("<f")
            else:
                raise Exception("Can't decode 4-byte byte order mark: " + hex(endianflag))
            return _binaryDecode(f, 4, dc, outArray, headers, extraCaptures)
        elif decode[3] == "Binary" and decode[4] == "8":
            #Determine endianness
            endianflag = f.read(8)
            if struct.unpack(">d", endianflag)[0] == 123456789012345.0:
                print "Big-endian 8-byte detected."
                dc = struct.Struct(">d")
            elif struct.unpack("<d", endianflag)[0] == 123456789012345.0:
                print "Little-endian 8-byte detected."
                dc = struct.Struct("<d")
            else:
                raise Exception("Can't decode 8-byte byte order mark: " + hex(endianflag))
            return _binaryDecode(f, 8, dc, outArray, headers, extraCaptures)
        else:
            raise Exception("Unknown OOMMF data format:" + decode[3] + " " + decode[4])

def _binaryDecode(filehandle, chunksize, decoder, targetarray, headers, extraCaptures):
    valm = headers.get("valuemultiplier",1)
    for k in range(int(headers["znodes"])):
        for j in range(int(headers["ynodes"])):
            for i in range(int(headers["xnodes"])):
                for coord in range(3): #Slowly populate, coordinate by coordinate
                    targetarray[i,j,k,coord] = decoder.unpack(filehandle.read(chunksize))[0] * valm
    print "Decode complete."
    return (targetarray, headers, extraCaptures)


def dirArray(inArray, dir):
    if   dir == 'x':  d = 0
    elif dir == 'y':  d = 1
    elif dir == 'z':  d = 2
    outArray = []
    for row in inArray:
        t = []
        for col in row:
            t.append(col[0][d])
            #print col[0][dir]
        outArray.append(t)
    return outArray

def cut_extr(x, max = 2000):
            xm = np.sqrt(x**2)
            if xm > max: return max * (x/xm)
            else: return x

# filtrowanie, usuwanie marginesow i za duzych wartosci
def filter_map(x, padding = 50, max = np.Inf):
        f = []
        for item in [item for item in x 
                     if ( (x.index(item) > padding) and x.index(item) < (len(x)- padding) )]:
            f.append( [elem for elem in item if (item.index(elem) > padding and (item.index(elem) < (len(item) - padding)) ) ])
        
        result = []
        for item in f:
            result.append( map(cut_extr, item) )  
        return result    

class FilterMap(object):
    u"filtrowanie mapy, zmiana maximum, wycinanie marginesow wzdluz Y"
    def __init__(self, max_val = np.Inf , padding = 0):
        self.max = max_val
        self.padding = padding
    def filter(self, map1):
        f = []
        for r in range(len(map1)):
            f0 = []
            for c in range(len(map1[0]) - 2*self.padding):
                cell = map1[r][c+self.padding]
                if np.sqrt(cell**2) < self.max:
                    f0.append( cell )
                else: f0.append(self.max*np.sqrt(cell**2)/cell)
            f.append(f0)
        self.result = f

def pproc(filename, inArray, dir, max_value, padding, show_plot):
    array = dirArray(inArray[0], dir)
    #with open('1.dat', 'w') as f:
    #    for item in xArray:    
    #        f.write(str(item))
    mat = FilterMap(max_value, padding)
    mat.filter(array)
    #plt.imshow(mat.result)
    
    maxV =  max(map(max, mat.result))
    minV =  min(map(min, mat.result))
    if (maxV**2 > minV**2): mv = np.sqrt(maxV**2)
    else: mv = np.sqrt(minV**2)

    print "max value of field: ", mv
    print "half of max value of field: ", mv/2
    norm = colors.normalize(-mv, mv)
    # MUMAX
    # norm = colors.normalize(-1, 1)
    # norm = colors.LogNorm()
    # plt.matshow(mat.result, cmap='RdBu', norm=colors.LogNorm() )
    plt.matshow(mat.result, norm=norm )
    plt.colorbar(shrink=.8)
    fig = plt.gcf()
    if (show_plot==True): plt.show()
    png_name = filename[0:(len(filename)-4)] + "_" "+.png"
    a = re.split(r'\\', png_name)
    addr = ""
    for i in range(len(a)-1):
        addr += a[i] +"\\"
    print addr
    addr += (dir+"_"+a[ len(a)-1 ])
    print addr
    #addr =  nn
    fig.savefig(addr, dpi=100)
    plt.close()


# wybieranie kierunku w ktorym liczy?
def processFile(filename, dir='x'):
    loadedArray= getData(filename)
    for (path, dirs, files) in os.walk('.'):
        break
    # if dir == 'x':
    #     # pproc(filename, outArray, 'x', np.Inf, padding=0, show_plot=show_plot)
    #     array = dirArray(inArray[0], dir)
    # elif dir == 'y':
    #     pproc(filename, outArray, 'y', np.Inf, padding=0, show_plot=show_plot)
    # elif dir == 'z':
    #     pproc(filename, outArray, 'z', np.Inf, padding=0, show_plot=show_plot)
    outArray = dirArray(loadedArray[0], dir)
    return outArray

def processFiles(path, dir='x'):
    nOfFiles = 25
    for (path, dirs, files) in os.walk(path):
        break
    sfiles = []
    for file in files:
        tail = file[ (len(file)-4) : (len(file))]
        if tail ==  ".ovf":
            sfiles.append(file)
            # print file
    a = []
    i = 0
    for file in sfiles:
        # tail = file[ (len(file)-4) : (len(file))]
        head= file[0:5]
        # print head
        if (head =="m0001" and i < (nOfFiles+1)):
            print "next file: ", i,"-th: ", file
            addr = path + str(file)
            if i == 0:
                if (dir != 'mod'):
                    a = np.asarray( processFile(addr, dir))
                else:
                    a = np.asarray( processFile(addr, 'x'))
                a = a * 0
            else:
                if (dir != 'mod'):
                    a += np.asarray( processFile(addr, dir))
                else:
                    #   MATLAB  numpy.array     numpy.matrix 
                    #   *       dot(a,b)        a * b           matrix multiply 
                    #   .*      a * b           multiply(a,b)   element-wise multiply 
                    x = np.asarray( processFile(addr, 'x'))
                    y = np.asarray( processFile(addr, 'y'))
                    a += np.sqrt(x*x+y*y)
            i +=1
    a = a / nOfFiles
    # a = (1/nOfFiles) * a
    maxV =  max(map(max, a))
    minV =  min(map(min, a))
    if (maxV**2 > minV**2): mv = np.sqrt(maxV**2)
    else: mv = np.sqrt(minV**2)
    print "MAX value of field: ", mv
    # print "half of max value of field: ", mv/2
    # norm = colors.normalize(-mv, mv)
    norm = colors.normalize(-1, 1)
    # MUMAX
    # norm = colors.normalize(-1, 1)
    # norm = colors.LogNorm()
    # plt.matshow(mat.result, cmap='RdBu', norm=colors.LogNorm() )
    plt.matshow(a, norm=norm )
    plt.colorbar(shrink=.8)
    fig = plt.gcf()
    png_name = path + "_RESULT" "+.png"
    nEl = re.split(r'\\', png_name)
    addr = ""
    for i in range(len(nEl)-1):
        addr += nEl[i] +"\\"
    # print addr
    addr += (dir+"_"+nEl[ len(nEl)-1 ])
    title1 = nEl[ len(nEl)-2]
    plt.title(title1)
    plt.show()
    # print addr
    #addr =  nn
    fig.savefig(addr, dpi=100)
    plt.close()

if __name__ == "__main__":
    # processFiles('C:\\Users\\Pawel\\workspace\\mumax3\\barman_semanti\\04.05\\mods_excitation\\500nm_Ha_0.3_r_8.5_6.68GHz.out\\', 'mod')
    # processFiles('C:\\Users\\Pawel\\workspace\\mumax3\\barman_semanti\\04.05\\mods_excitation\\500nm_Ha_0.3_r_8.5_6.94GHz.out\\', 'mod')
    # processFiles('C:\\Users\\Pawel\\workspace\\mumax3\\barman_semanti\\04.05\\mods_excitation\\200nm_r_8.5_4.85GHz.out\\', 'mod')
    processFiles('C:\\Users\\Pawel\\workspace\\mumax3\\barman_semanti\\04.05\\mods_excitation\\200nm_r_8.5_9.8GHz.out\\', 'mod')